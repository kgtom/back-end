## 一、场景
 * 用户注册，赠送钻石(或者积分)

## 二、理论来源
* 传统事务ACID
* CAP：牺牲一致性C，追求最终一致性
* BASE:是CAP的延伸，牺牲强一致性，获得高可用,即柔性事务
## 三、解决方案
* 1.2pc 、3pc 、tcc
* 2.柔性事务：
  - 消息队列异步化操作：消息是不可靠的，支持重试但要保证api幂等性，业务场景不同，幂等也不同，最简单根据业务流水ID做去重(排重表)
  - 后台console进程：定时check，根据状态机去执行(或者结合查询模式，先查一下，然后再决定是否补偿）
  - 查询模式：执行成功后，再查询一次，确保无误
  - 引入日志补偿机制(重试：正向补偿，回滚：反向补偿)，日志记录事务开始、结束状态，日志redo\undo日志与业务操作在一个事务中。
  - 辅助业务明细表：减少对主表热点数据锁抢占的情况。比如：扣减热卖商品a库存数量，为了避免频繁修改a的库存数量，可以在下单时只增加到明细表。库存数量=a表数量-明细表数量
  - 乐观锁使用：使用version字段
  
  ### 2pc 、3pc 、tcc
  **2pc：**
   * 两个角色：1.事务管理器 M 2.分布式事务参与者 A、B
   * 分两个阶段：1.prepare阶段，A、B告诉M，可以准备好了，2.提交确认，M告知A、B 可以提交了 3.如果A、B遇到问题，则执行响应rollback操作。
   * 缺点：
       - M是单点，遇到故障,则参与者 A、B收不到执行或回滚的通知
       - 性能方面：在m未告知A、Bcommit之前，数据库资源一直占用，只有commit后才能释放
       - 丢失消息数据不一致：提交确认阶段，遇到网络问题，A提交了，B未提交，但网络不畅，M未收到B的异常消息
   
   **3pc：**
  * 3pc在2pc基础上增加超时机制，解决单点故障，如果超时后，参与者A、B自动提交，释放本地数据库资源，但性能问题和不一致问题没有解决
  
**tcc:**(补偿事务)
* tcc:try-confirm-cancel:区别2pc是，2pc是跨库的层面，而tcc是各自业务逻辑代码层面。
* 缺点：1.对应用代码侵入性强，耦合在业务代码里面 2.增加代码复杂性，对每一个操作对应commit/cancel方法，并且对方法遵循幂等操作，另外如果遇到网络、系统错误对应不同回滚策略

  ### 场景实践
  
 * 场景描述：用户注册后，发送给消息队列，钻石服务消费消息队列，赠送钻石。
 * 常见问题：
    - 1.用户注册成功，但发送mq失败？如何再次发送
    - 2.钻石服务接收到mq，但消费失败？如何再次消费(如果存储mq记录失败了，mq会重发）

* 解决方案：
    - 1.用户服务：两个张表，用户表t1 和用户注册记录表 t2，一个本地事务。t2表字段 publish_status =1初始化状态 ,后台console定时任务拉取publish_status=1的发送mq,如果发送成功则publish_status=2，否则继续重试，重试超过5次，报警机制通知人工，跟进处理(自身、第三方问题)
    - 2.钻石服务：两张表，用户钻石表 t3 和用户钻石记录表 t4。从消费队列获取到记录，先存储t4表,t4中字段 consumer_status=1 未消费，后台console定时任务拉取t4 consumer_status=1的给用户增加钻石，如果增加成功则 consumer_status=2，否则继续重试，重试超过5次，报警机制通知人工，跟进处理
    - 3.每天业务非高峰期，后台check任务 检查前天注册用户是否都发送钻石
