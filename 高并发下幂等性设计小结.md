

## 本节大纲
* [一、背景](#1)
* [二、常见应用场景](#2)
* [三、设计方案](#3)
* [四、总结](#4)



## <span id="1">一、背景</span>
* 在分布式服务(微服务)系统中，A系统调用B系统api，有些场景下无论调用一次还是多次，期待返回的结果是一样的，比如支付场景。
* 服务之间调用HTTP或者RPC,调用时遇到用户重复提交、网络问题、Nginx重发导致多次调用
* 针对增删改查四种方式，新增、修改(尤其时增量)一定要考虑幂等性，查询、删除可以不需要考虑。


## <span id="2">二、常见应用场景</span>
### 1.创建业务订单：
例如：用户实名认证，前端重复提交认证数据，认证主表只存储一次认证成功的记录，不应该有多条
### 2.支付场景：
例如：用户购买钻石，微信或者IAP支付遇到网络或系统bug重发，应该只支付一次钱，不应该支付多笔
### 3.支付后续流程：
例如：支付成功后，发送消息给用户，应该只发一次，不应该收到多次消息


## <span id="3">三、设计方案</span>
### 3.1数据库层面
* 数据库唯一索引(单列或联合键)，并发要求不高的场景，使用db唯一索引做校验即可，没有必要使用分布式锁，例如：
  - 1.实名认证主表，userID+IDCard做唯一索引
  - 2.充值成功派发商品：如果是串行调用，直接使用userID+requestID+eventType 做唯一索引通过db校验是否发放； 如果是并发场景，则先使用分布式锁，再查询是否发放过，新增时再通过唯一索引再次校验.
* 数据库悲观锁与乐观锁
    - 1.悲观锁：一般在事务中用，排它锁
    - 2.乐观锁：通过版本号机制,注意where条件最好用主键或者唯一索引，这样操作是行级锁，否则update时会锁表
     ~~~
     update t set xxx=xx,version=version+1 where id=xx and version=xx
     ~~~
### 3.2.接口层面
* 分布式锁(redis或者zk)：高并发场景杀手锏，保证同一时刻只有一个操作进行
* token机制：防止页面重复(用户提交、网络、Nginx)提交，同时一定程度对提交接口的限流。token是一次性的。流程如下：
   - 1.客户端调用提交api前，先获取token,此token存储在服务端redis中并设置ttl
   - 2.客户端提交时，带着token，服务端通过del或者lua(get+del)操作成功，则证明token有效，执行后续操作，如果后续操作失败，则生成新token返回。保证同一个token只能使用一次。
* 状态机机制：通过代码逻辑根据某种状态处理，比如：
  - 1.支付时，只处理状态为待支付的订单
  - 2.支付成功后，派发商品，只处理状态为支付成功的订单

## <span id="4">四、小结</span>
* 1.根据不同并发场景，选择最佳方式
* 2.有时候需要组合两种方式，比如：使用分布式锁+db索引双重校验
* 3.幂等性设计在设计增改api时一定要考虑，因为查询、删除db支持幂等性
