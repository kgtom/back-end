

### 一、缓存失效

* 背景：请求一个或多个key瞬间失效了，主要因为设置ttl时间问题
* 解决方案有二： 
   - 1.空返回：ttl=base+随机时间，避免瞬间失效。失效后返回空、并设置较短ttl(详见缓存穿透)，使用互斥锁保证只有一个G去
   - 2.缓存预热+持久化：比如 热门feed流，需要提前做好缓存预热或者cache持久化
### 二、缓存穿透
* 背景： 恶意请求缓存中不存在的key,导致流量到db。
* 解决方案有两个：
   - 1.异步互斥锁：从cache获取不到，直接返回空，并且将空值set cache+ ttl较短,然后只有一个拿到互斥锁，异步开启gorotine 请求db,更新cache
   - 2.拦截器：内部维护合法key集合，先判断请求key是否合法，不合法直接返回空
### 三、缓存雪崩
* 背景：大面积缓存失效，请求直接到db，db压力陡升
* 解决方案：
  - 1.异步互斥锁，(增加一点，设置db读写开关，如果量大了，先关闭读接口，返回错误，优先保证写接口)
  - 2.缓存多副本策略：一个失效了，请求另一个，然后异步更新失效cache的key
  - 3.预警机制：发现请求变慢，提前自动降级
### 四、数据不一致
* 背景：cache与db 数据不一致
* 解决方案：
  - 1.如果对数据要求强一致性，不要使用cache
  - 2.异步队列方法：先更新数据库，再删cache。可能存在删除cache失败的问题，提供一个补偿措施,异步开启新goroutine获取db,更新cache(前提是队列中不存在该key)，如果更新cache失败，则key放在队列，cache恢复后，删除队列，再次重试更新cache
### 五、数据并发竞争
* 背景：多个客户端并发get key ，然后set key，如果不使用lua的前提下，会存在value不一致问题。
* 解决方案：
  - 1.分布式锁，获取到锁再去更新
  - 2.使用lua，将set get 一个原子操作
  - 3.类似于db乐观锁，增加时间戳version，比较get时获取的version和set时的version大小
### 六、热key
* 背景：单机或者一主一从redis不需要考虑热key，因为无论怎样处理，最终还是在原来redis上处理。现在只针对集群redis热key的问题。例如：在大促、秒杀场景下某个热key，会导致集群中某个机器访问频繁，集群性能不均。
* 解决方案：
  - 不想所有请求在一台机器，那么均匀的打散到其它机器上，如何均匀呢？假如集群数量N

~~~


const M = N * 2
randomKey = GenRandomNum(0, M)
bakHotKey = hotKey + "_" + randomKey
// 拉取备份的bakHotKey
data := redis.GET(bakHotKey)
if data ==""{
    // 假如bakHotKey失效，再尝试拉取hotKey
    data = redis.GET(hotKey)
    if data == "" {
        // hotKey也失效，从DB拉取
        data = GetFromDB()
        // 写入主redis数据
        redis.SET(hotKey, data, expireTime)
        // 写入备份redis数据,加上随机时间，避免缓存雪崩
        redis.SET(bakHotKey, data, expireTime + GenRandomNum(0,10))
    } else {
        // 否则只需要直接写入bakHotKey，不需访问DB
         redis.SET(bakHotKey, data, expireTime + GenRandomNum(0,10))
    }
} 

~~~


  
 ### 七、大key 
 * 判断大key的标准：字符串类型超过10k，其它类型元素过大，例如list超过10240
 * 大key带来影响：占用内存大、占用网络资源、容易造成redis堵塞
 * 解决方案：阿里云命令,使用scan方式寻找大key,不会堵塞redis。
  ```
  redis-cli -h{ip} -p{port} bigkeys
  ```
  
  
  ### 八、Redis 为什么是单线程的
* 如果是多线程，涉及到锁的问题，另外轮流使用cpu资源，带来上下文切换和竞争条件的代价，一次上下文切换大约1500us微秒(1ms=1k*us)。但redis是纯内存的操作，用单线程去对内存多次读写，省去上下文切换的耗时，而多线程适用于磁盘、网络I/O操作。
* redis 瓶颈不在于cpu，而是在于内存和带宽的大小
* 从内存读取1M数据，大约200us，试想如果是多线程需要再加上上下文切换时间，延迟很大了。

### 九、Redis 为什么这么快
* 纯内存操作
* 采用单线程，避免上下文切换和竞争条件
* 采用非堵塞的IO多路复用机制,基于事件的驱动
* 合理高效的数据结构，例如：ziplist、skiplist


### 十、Redis 线程模型
* 1.redis基于Reactor(基于事件驱动)模式开发了自己的文件事件处理器，包括：套接字、 I/O 多路复用机制、 文件事件分派器（dispatcher）、以及事件处理器。
~~~

多个client 套接字请求--->io多路复用---->有序队列(将并行请求，转为串行执行)---->dispatcher-->事件处理器(连接应答、命令请求、命令回复、复制)

例如：set name tom,最后达到事件处理器，先交给连接应答处理器，其创建了一个能与客户端通信的socket0，然后交给命令请求处理器，将客户端key:name, value:tom写到内存，然后交给命令回复
处理器，返回给客户端。最后dispatcher会解除socket01与命令回复处理器的关联。

~~~

### 十一、Redis 与memcahed的区别
* 存储数据类型：redis 支持五种数据结构，后者只支持string
* 线程模型：redis 单线程，后者多线程
* 持久化：redis 可以将数据持久化到磁盘，后者只在内存中
* 集群：redis原生支持集群模式，后者没有原生的，只能依赖客户端来实现往集群分区写入数据

### 十二、redis常见的集群方案
* 1.客户端hash分片:不推荐，因为在扩容/缩容时，必须手动程序调整槽点，出现故障不能自动转移，维护成本高
* 2.主从复制：不推荐，一主多从，主节点压力大，适合业务前期数据量少
* 3.哨兵sentinel机制:推荐，提供的高可用方案
   - 在主从复制集群的基础上，增加Sentinel集群监控整个Redis集群。如果发现master节点发生故障时，Sentinel通过raft算法选举主sentinel,让其选举出新的master

优点在于支持集群高可用，高性能读写，缺点在于没有实现数据分片，每个节点需要承载完整数据集，负载能力受当个Redis服务器限制，仅支持通过增加机器内存实现垂直扩容，不支持水平扩展

* 4.官方方案redis-cluster:推荐，支持hash分片，故障转移，水平节点扩容
    集群中有多个主节点，每个主节点有多个从节点，主从节点间数据一致，最少需要3个主节点，每个主节点最少需要1个从节点
- 高可用：当master节点发送故障时，自动主从切换
- 高性能：主节点提供读写服务，从节点只读服务，提高系统吞吐量
- 可扩展性：集群的数据分片存储，主节点间数据各不同，各自维护对应数据，可以新增节点进行扩容


### 十三、redis持久化的方式以及区别
* RDB:db键值对的快照，子进程根据save策略去保存RDB文件，不影响主进程处理客户端请求，性能好，一个文件，操作简单；缺点：容易丢失数据(取决于save策略的时间点)，另外服务器载入RDB文件期间，主进程处于堵塞，影响正常请求
* AOF:三种方式写文件-->重写文件-->后台重写文件，备份机制稳健，恢复快；缺点：占磁盘，备份速度慢，每次都要写
* 区别：RDB占磁盘小，操作简单，恢复快，容易丢数据；AOF占磁盘大，恢复慢，数据安全数据最终一致

