
### 一、缓存失效

* 背景：请求一个或多个key瞬间失效了，主要因为设置ttl时间问题
* 解决方案有二： 
   - 1.空返回：ttl=base+随机时间，避免瞬间失效。失效后返回空、并设置较短ttl(详见缓存穿透)
   - 2.缓存预热+持久化：比如 热门feed流，需要提前做好缓存预热或者cache持久化
### 二、缓存穿透
* 背景： 恶意请求缓存中不存在的key,导致流量到db。
* 解决方案有两个：
   - 1.异步互斥锁：从cache获取不到，直接返回空，并且将空值set cache+ ttl较短,然后只有一个拿到互斥锁，异步开启gorotine 请求db,更新cache
   - 2.拦截器：内部维护合法key集合，先判断请求key是否合法，不合法直接返回空
### 三、缓存雪崩
* 背景：大面积缓存失效，请求直接到db，db压力陡升
* 解决方案：
  - 1.异步互斥锁，(增加一点，设置db读写开关，如果量大了，先关闭读接口，返回错误，优先保证写接口)
  - 2.缓存多副本策略：一个失效了，请求另一个，然后异步更新失效cache的key
  - 3.预警机制：发现请求变慢，提前自动降级
### 四、数据不一致
* 背景：cache与db 数据不一致
* 解决方案：
  - 1.如果对数据要求强一致性，不要使用cache
  - 2.异步队列方法：先更新数据库，再删cache。可能存在删除cache失败的问题，提供一个补偿措施,异步开启新goroutine获取db,更新cache(前提是队列中不存在该key)，如果更新cache失败，则key放在队列，cache恢复后，删除队列，再次重试更新cache
### 五、数据并发竞争
* 背景：多个客户端并发get key ，然后set key，如果不使用lua的前提下，会存在value不一致问题。
* 解决方案：
  - 1.分布式锁，获取到锁再去更新
  - 2.使用lua，将set get 一个原子操作
  - 3.类似于db乐观锁，增加时间戳version，比较get时获取的version和set时的version大小
### 六、热key

### 七、大key
