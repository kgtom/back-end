


### 遵循原则
* 使用索引：最左前缀匹配、
* 不能使用索引：前置模糊查询不能使用 %xxx、反向查找not in、or，因为会导致索引失效，全表索引，但可以使用 xxx%，以xxx开头查找
* 使用join时:可以先where过滤一下，再join，再使用索引
* 字段长度尽量短
* 单表建立 主键单例索引
* 多表链接：联合索引
* where、分组、排序建立索引

### 优化方法
* 开启慢日志查询
* explain使用
分析 type 类别
ALL < index < range ~ index_merge < ref < eq_ref < const < system

### 索引优势
* 提高查询速度、减少磁盘io操作，二分查找
* 减少排序功能，b+tree，在产生数据的时候，就排好序了(例如id主键索引)
* B+树多路搜索树，树高2-4层，每秒100次io,查询一次0.02-0.04s，利于搜索(为什么索引使用B+树)

### 索引劣势
* 占用存储空间，但条最多5个索引
* add、update、delete时候，需要更新索引



#### 二叉树
* 每个结点都包含一个元素以及n个子树，这里0≤n≤2。
* 左子树和右子树是有顺序的，次序不能任意颠倒。左子树的值<父结点<右子树的值

最坏情况:单支树，一棵树节点组成一个链表，查询O(n),最优情况：以扇形结构散开O(logN)
为了不出现单支树，引出平衡二叉树

###  平衡二叉树
 * 满足二叉树，并且 还有满足 左右两树高度差不超过1
 * 经过左旋或右旋，形成平衡二叉树，复杂度和二分查找一样对数时间内完成O(log2^N) 或者O(logN) 即以2为底数的对数复杂度。

一颗平衡二叉树能容纳多少的结点呢？这跟树的高度是有关系的，
树的高度(深度)为h，那每一层最多容纳的结点数量为2^(h-1)，
整棵树最多容纳节点数2^0+2^1+2^2+...+2^(h-1)，即：2^h -1


这样计算，100w数据树的高度大概在20左右，那也就是说从有着100w条数据的平衡二叉树中找一个数据，最坏的情况下需要20次查找。如果是内存操作，效率也是很高的！但是我们数据库中的数据基本都是放在磁盘中的，每读取一个二叉树的结点就是一次磁盘IO，这样我们找一条数据如果要经过20次磁盘的IO？那性能就成了一个很大的问题了！那我们是不是可以把这棵树压缩一下，让每一层能够容纳更多的节点呢？

理解：
高度的定义为：从结点x向下到某个叶结点最长简单路径中边的条数
深度的定义：从根节点往下的距离，从根节点到该节点的最长简单路径边的条数
对于整个树来讲：树的高度==树的深度
对于树中相同深度的每个结点来说，它们的高度不一定相同，这取决于每个结点下面的叶结点的深度。


### B-tree(B杠tree,不是B减tree)

* 多路搜索树
* 关键字集合分布在整颗树中；
* 任何一个关键字出现且只出现在一个结点中；
* 二分查找


### B+tree
* 在B+树基础上，做了优化 有n棵子树的结点中含有n个关键字，每个非叶子节点不保存数据，只用来索引，所有数据都保存在叶子节点
* 所有叶子节点之间都有一个链指针且链表是有序的
* 多路搜索树 二分查找
* 更适合数据文件索引系统


### 选择 B- or B+
* B-Tree因为非叶子结点也保存具体数据，所以在**查找某个关键字**的时候找到即可返回。而B+Tree所有的数据都在叶子结点，每次查找都得到叶子结点。所以在同样高度的B-Tree和B+Tree中，B-Tree查找某个关键字的效率更高
* 由于B+Tree所有的数据都在叶子结点，并且结点之间有指针连接，在找大于某个关键字或者小于某个关键字的**范围数据和排序数据**的时候，B+Tree只需要找到该关键字然后沿着链表遍历就可以了，而B-Tree还需要遍历该关键字结点的根结点去搜索。
* 由于B-Tree的每个结点（这里的结点可以理解为一个数据页）都存储主键+实际数据，而B+Tree非叶子结点只存储关键字信息，而每个页的大小有限是有限的。所以同一页能存储的B-Tree的数据会比B+Tree存储的更少，因为B-除了存储关键字信息还存储实际数据，这样同样总量的数据，B-Tree的深度会更大，增大查询时的磁盘I/O次数，进而影响查询效率。



### mysql 索引使用场景
* B+：聚集索引和非聚集索引，主键查询、按主键范围查询，查询一条记录的复杂度为O(LogN),相当于二分查找
* hash:等值查找（=、 <、>、in）为主，Hash索引是更高效的选择,O(1)


>reference
[wx](https://mp.weixin.qq.com/s/zA9KvCkkte2mTWTcDv7hUg)


