## 本节大纲 
* [一、为什么使用redis](#1)  
* [二、单线程的redis为什么这么快](#2)  
* [三、redis的数据类型，以及每种数据类型的使用场景](#3)  
* [四、使用redis有什么缺点](#4)  
* [五、redis的过期策略以及内存淘汰机制](#5)  
* [六、redis和数据库双写一致性问题](#6)  
* [七、如何应对缓存穿透和缓存雪崩问题](#7)  
* [八、如何解决redis的并发竞争问题](#8)  
* [九、如何利用redis分布式锁实现控制并发](#9)  
* [十、Redis与Memcached比较](#10)
* [十一、Redis单机、集群部署](#11)



### <span id="1">一、为什么使用redis</span>

**分析**:主要是从两个角度去考虑:**性能**和**并发**。当然，redis还具备可以做分布式锁等功能，但完全可以使用etcd、zk代替，并不是非要使用redis。
**回答**:如下所示，分为两点  
**（一）性能**  
 场景：执行时间久，且结果不频繁变动的SQL，将运行结果放入redis缓存，后面请求从缓存中迅速获取数据,提高用户体验

  
**（二）并发**  
在大并发的情况下，所有的请求先访问到redis，而不是直接访问数据库。  




###  <span id="2">二、单线程的redis为什么这么快</span>

**分析**:这个问题其实是对redis内部机制的一个考察。
**回答**:主要是以下三点  
(一)纯内存操作  
(二)单线程操作，避免了频繁的上下文切换  
(三)采用了非阻塞**I/O多路复用机制**


 多人送车送快递，一人一车送快递比较： 
1、经营方式一就是传统的并发模型，每个I/O流(快递)都有一个新的线程(快递员)管理。  
2、经营方式二就是I/O多路复用。只有单个线程(一个快递员)，通过跟踪每个I/O流的状态(每个快递的送达地点)，来管理多个I/O流。

下面类比到真实的redis线程模型，
简单来说，就是。我们的redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。  
需要说明的是，这个I/O多路复用机制，redis还提供了select、epoll、evport、kqueue等多路复用函数库，大家可以自行去了解。

###  <span id="3">三、redis的数据类型，以及每种数据类型的使用场景</span>

**分析**：建议，在项目中用到后，再类比记忆，体会更深，不要硬记。基本上，一个合格的程序员，五种类型都会用到。  
**回答**：一共五种

#### (一)String

最常规的set/get操作，value可以是String也可以是数字.  
**场景**：

*   **缓存功能**：
*   结合 **incr命令**做 [计数、限流api功能](http://www.redis.cn/commands/incr.html)
*   存储图片或者序列化的数据

#### (二)hash

特别适合用于存储对象，value存放结构化的对象，方便的就是操作其中的某个字段。

**场景**：

*   做**用户登录**的时候，就是用这种数据结构存储用户信息，以 userId 作为key，value 用户信息，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。
    
*   每篇文章 都有点赞数、评论数、转发数和浏览数四条属性，这时用`hash`进行计数会更好，将该计数器的 key 设为`article_id`，`hash`的 field 为`like_number`、`comment_number`、`forward_number`和`view_number`，在对应操作后通过**hincrby**使`hash 中`的 field 自增
    

#### (三)list

简单的字符串列表，按照插入顺序排序

**场景**：

*   **做简单的消息队列的功能**。
    
*   **做秒杀系统订单列表能**，性能极佳，用户体验好。
    
*   `list`作为双向链表，公用的时间轴。如用户大事件记录。
    

#### (四)set

String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。  
Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。

**场景**：

*   因为set堆放的是一堆不重复值的集合。所以可以做**全局去重的功能**。

*   注册账号时，手机号出重。
    
*   **好友关系** 使用交集、并集、差集等操作，可以**计算共同喜好，全部的喜好，自己独有的喜好等功能**。
    
*   **倒排索引** 是构造搜索功能的最常见方式，在 Redis 中也可以通过`set`进行建立倒排索引，这里以简单的拼音 \+ 前缀搜索城市功能举例：
    

假设一个城市`北京`，通过拼音词库将`北京`转为`beijing`，再通过前缀分词将这两个词分为若干个前缀索引，有：`北`、`北京`、`b`、`be`…`beijin`和`beijing`。将这些索引分别作为`set`的 key（例如:`index:北`）并存储`北京`的 id，倒排索引便建立好了。接下来只需要在搜索时通过关键词取出对应的`set`并得到其中的 id 即可。

#### (五)sorted set

有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。

**场景**：

*   **排行榜** 如果应用有一个发帖排行榜的功能，便选择`sorted set`吧，将集合的 key 设为`POST_RANK`。当用户发帖后，使用`zincrby`将该用户 id 的 score 增长 1。`sorted set`会重新进行排序，用户所在排行榜的位置也就会得到实时的更新。
    
*   参照另一篇[《分布式之延时任务方案解析》](https://www.cnblogs.com/rjzheng/p/8972725.html)，该文指出了sorted set可以用来做**延时任务**。
    

### <span id="4">四、使用redis有什么缺点</span>

**分析**:大家用redis这么久，这个问题是必须要了解的，基本上使用redis都会碰到一些问题，常见的也就几个。  
**回答**:主要是四个问题  
(一)缓存和数据库双写一致性问题  
(二)缓存雪崩问题  
(三)缓存击穿问题  
(四)缓存的并发竞争问题  
答案继续往下看。


### 5、redis的过期策略以及内存淘汰机制

**分析**:这个问题其实相当重要，到底redis有没用到家，这个问题就可以看出来。比如你redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的，这个问题思考过么？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?  
**回答**:  
redis采用的是定期删除+惰性删除策略。  
**为什么不用定时删除策略?**  
定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.  
**定期删除+惰性删除是如何工作的呢?**  
定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。  
于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。  
**采用定期删除+惰性删除就没其他问题了么?**  
不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用**内存淘汰机制**。  
在redis.conf中有一行配置

    # maxmemory-policy volatile-lru
    

该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)  
1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。**应该没人用吧。**  
2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。**推荐使用，目前项目在用这种。**  
3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。**应该也没人用吧，你不删最少使用Key,去随机删。**  
4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。**这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐**  
5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。**依然不推荐**  
6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。**不推荐**  
ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。

### 6、redis和数据库双写一致性问题

**分析**:一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。就是**如果对数据有强一致性要求，不能放缓存。**我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说，只能说**降低不一致发生的概率**，无法完全避免。因此，有强一致性要求的数据，不能放缓存。  
**回答**:

*  常规的更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，开启新gouroutine获取db,set 缓存中。
    
    

### 7、如何应对缓存穿透和缓存雪崩问题

**分析**:这两个问题，说句实在话，一般中小型传统软件企业，很难碰到这个问题。如果有大并发的项目，流量有几百万左右。这两个问题一定要深刻考虑。  
**回答**:如下所示  
**缓存穿透**，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。  
**解决方案**:  
(一)利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试  
(二)采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做**缓存预热**(项目启动前，先加载缓存)操作。  
(三)提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。  
**缓存雪崩**，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。  
**解决方案**:  
(一)给缓存的失效时间，加上一个随机值，避免集体失效。  
(二)使用互斥锁，但是该方案吞吐量明显下降了。  
(三)双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。然后细分以下几个小点

*   I 从缓存A读数据库，有则直接返回
*   II A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。
*   III 更新线程同时更新缓存A和缓存B。

### 8、如何解决redis的并发竞争key问题

**分析**:这个问题大致就是，同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。需要说明一下，博主提前百度了一下，发现答案基本都是推荐用redis事务机制。博主**不推荐使用redis的事务机制。**因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，**redis的事务机制，十分鸡肋。**  
**回答:**如下所示  
(1)如果对这个key操作，**不要求顺序**  
这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。  
(2)如果对这个key操作，**要求顺序**  
假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC.  
期望按照key1的value值按照 valueA–>valueB–>valueC的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下

    系统A key 1 {valueA  3:00}
    系统B key 1 {valueB  3:05}
    系统C key 1 {valueC  3:10}
    

那么，假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。

其他方法，比如利用队列，将set方法变成串行访问也可以。总之，灵活变通。

### 9、如何利用redis分布式锁实现控制并发

#### redis命令解释

说道Redis的分布式锁都是通过setNx命令结合get set来实现的，在讲之前我们先了解下setNx和get set的意思，在redis官网是这样解释的  
注：redis的命令都是原子操作

#### SETNX key value

将 key 的值设为 value ，当且仅当 key 不存在。  
若给定的 key 已经存在，则 SETNX 不做任何动作。  
SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。  
**可用版本：**  
1.0.0+  
**时间复杂度：**  
O(1)  
**返回值：**  
设置成功，返回 1 。  
设置失败，返回 0 。
 ~~~
    redis> EXISTS job                # job 不存在
    (integer) 0
    redis> SETNX job "programmer"    # job 设置成功
    (integer) 1
    redis> SETNX job "code-farmer"   # 尝试覆盖 job ，失败
    (integer) 0
    redis> GET job                   # 没有被覆盖
    "programmer"
  
  ~~~

#### GETSET key value

将给定 key 的值设为 value ，并返回 key 的旧值(old value)。  
当 key 存在但不是字符串类型时，返回一个错误。  
**可用版本：**  
1.0.0+  
**时间复杂度：**  
O(1)  
**返回值：**  
返回给定 key 的旧值。  
当 key 没有旧值时，也即是， key 不存在时，返回 nil 。
~~~
    redis> GETSET db mongodb    # 没有旧值，返回 nil
    (nil)
    redis> GET db
    "mongodb"
    redis> GETSET db redis      # 返回旧值 mongodb
    "mongodb"
    redis> GET db
    "redis"
    
~~~
#### 思路

为了让分布式锁的算法更稳键些，持有锁的客户端在解锁之前应该再检查一次自己的锁是否已经超时，再去做DEL操作，因为可能客户端因为某个耗时的操作而挂起，操作完的时候锁因为超时已经被别人获得，这时就不必解锁了。

另外： 使用Lua脚本放到redis的eval方法里执行，这样就可以保证这命令的原子性。
[详见](https://github.com/kgtom/lua-notes/blob/master/redis%2Blua%E5%AE%9E%E7%8E%B0%E7%A7%92%E6%9D%80%E6%9C%BA%E7%A5%A8%E5%9C%BA%E6%99%AF.md)
###Redis与Memcached比较

两者都是非关系型内存键值数据库。有以下主要不同：

> 数据类型

Memcached 仅支持字符串类型，而 Redis 支持五种不同种类的数据类型，使得它可以更灵活地解决问题。

> 数据持久化

Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。

> 分布式

Memcached 不支持分布式，只能通过在客户端使用一致性哈希这样的分布式算法来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。

Redis Cluster 实现了分布式的支持。

> 内存管理机制

在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘。而 Memcached 的数据则会一直在内存中。

Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题，但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。

### <span id="11">十一、Redis单机、集群部署</span>
#### 单机部署
 场景：容量或请求不高的小型存储
 部署：
  * 主从模式，一个master，至少一个slave,主从两个哨兵(sentinel)
  * sentinel作用：监控(所有redis是否正常运行)；故障转移(当master节点发生宕机时，Sentinel会提升 slave 节点为新的 maste)
 缺点：请求多了，性能瓶颈；扩容时只能停机扩容
#### 集群部署
 场景：当容量超过20G或者系统吞吐量qps超过20w/s时，建立集群。通过中间件将流量分散到各个实例。
 部署：
 
 缺点：容易导致请求分配不均，请求倾斜。

> reference：
[cnblogs](https://www.cnblogs.com/rjzheng/p/9096228.html)
[cnblogs](https://www.cnblogs.com/rjzheng/p/9096228.html)  
[csdn](https://blog.csdn.net/fuyuwei2015/article/details/72870131)  
[scienjus](http://www.scienjus.com/redis-use-case/)  
[Cyc2018](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/Redis.md#%E5%9B%9Bredis-%E4%B8%8E-memcached)
[wx](https://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&mid=2653550162&idx=1&sn=3a028865fe152de7b337c910c00b9ba2&chksm=813a67cab64deedc132ca69ea690f3164c4a0027a7f975284c849a7281ef778a8d102fccabde&scene=21#wechat_redirect)
