## 本节大纲 
* [一、为什么使用redis](#1)  
* [二、单线程的redis为什么这么快](#2)  
* [三、redis的数据类型，以及每种数据类型的使用场景](#3)  
* [四、使用redis有什么缺点](#4)  
* [五、redis的过期策略以及内存淘汰机制](#5)  
* [六、redis和数据库双写一致性问题](#6)  
* [七、如何应对缓存穿透和缓存雪崩问题](#7)  
* [八、如何解决redis的并发竞争问题](#8)  
* [九、如何利用redis分布式锁实现控制并发](#9)  
* [十、Redis与Memcached比较](#10)
* [十一、Redis单机、集群部署](#11)



### <span id="1">一、为什么使用redis</span>

**分析**:主要是从两个角度去考虑:**性能**和**并发**。当然，redis还具备可以做分布式锁等功能，但完全可以使用etcd、zk代替，并不是非要使用redis。
**回答**:如下所示，分为两点  
**（一）性能**  
 场景：执行时间久，且结果不频繁变动的SQL，将运行结果放入redis缓存，后面请求从缓存中迅速获取数据,提高用户体验

  
**（二）并发**  
在大并发的情况下，所有的请求先访问到redis，而不是直接访问数据库。  




###  <span id="2">二、单线程的redis为什么这么快</span>

**分析**:这个问题其实是对redis内部机制的一个考察。
**回答**:主要是以下三点  
(一)纯内存操作  
(二)单线程操作，避免了频繁的上下文切换  
(三)采用了非阻塞**I/O多路复用机制**


 多人送车送快递，一人一车送快递比较： 
1、经营方式一就是传统的并发模型，每个I/O流(快递)都有一个新的线程(快递员)管理。  
2、经营方式二就是I/O多路复用。只有单个线程(一个快递员)，通过跟踪每个I/O流的状态(每个快递的送达地点)，来管理多个I/O流。

下面类比到真实的redis线程模型，
简单来说，就是。我们的redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。  
需要说明的是，这个I/O多路复用机制，redis还提供了select、epoll、evport、kqueue等多路复用函数库，大家可以自行去了解。

###  <span id="3">三、redis的数据类型，以及每种数据类型的使用场景</span>

**分析**：建议，在项目中用到后，再类比记忆，体会更深，不要硬记。基本上，一个合格的程序员，五种类型都会用到。  
**回答**：一共五种

#### (一)String

最常规的set/get操作，value可以是String也可以是数字。  
**场景**：

*   **缓存功能**：(序列化用户信息、详情页面信息）
*   结合 **incr命令**做 [计数、限流api功能](http://www.redis.cn/commands/incr.html)

#### (二)hash

特别适合用于存储对象，value存放结构化的对象，方便的就是操作其中的某个字段。

**场景**：

*   做**用户登录**的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。
    
*   每条微博都有点赞数、评论数、转发数和浏览数四条属性，这时用`hash`进行计数会更好，将该计数器的 key 设为`weibo:weibo_id`，`hash`的 field 为`like_number`、`comment_number`、`forward_number`和`view_number`，在对应操作后通过**hincrby**使`hash 中`的 field 自增
    

#### (三)list

简单的字符串列表，按照插入顺序排序

**场景**：

*   **做简单的消息队列的功能**。
    
*   **做基于redis的分页功能**，性能极佳，用户体验好。
    
*   `list`作为双向链表，不光可以作为队列使用。如果将它用作栈便可以成为一个公用的时间轴。当用户发完微博后，都通过`lpush`将它存放在一个 key 为`LATEST_WEIBO`的`list`中，之后便可以通过`lrange`取出当前最新的微博。
    

#### (四)set

String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。  
Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。

**场景**：

*   因为set堆放的是一堆不重复值的集合。所以可以做**全局去重的功能**。
    
*   **好友关系** 使用交集、并集、差集等操作，可以**计算共同喜好，全部的喜好，自己独有的喜好等功能**。
    
*   **倒排索引** 是构造搜索功能的最常见方式，在 Redis 中也可以通过`set`进行建立倒排索引，这里以简单的拼音 \+ 前缀搜索城市功能举例：
    

假设一个城市`北京`，通过拼音词库将`北京`转为`beijing`，再通过前缀分词将这两个词分为若干个前缀索引，有：`北`、`北京`、`b`、`be`…`beijin`和`beijing`。将这些索引分别作为`set`的 key（例如:`index:北`）并存储`北京`的 id，倒排索引便建立好了。接下来只需要在搜索时通过关键词取出对应的`set`并得到其中的 id 即可。

#### (五)sorted set

有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。

**场景**：

*   **排行榜** 如果应用有一个发帖排行榜的功能，便选择`sorted set`吧，将集合的 key 设为`POST_RANK`。当用户发帖后，使用`zincrby`将该用户 id 的 score 增长 1。`sorted set`会重新进行排序，用户所在排行榜的位置也就会得到实时的更新。
    
*   参照另一篇[《分布式之延时任务方案解析》](https://www.cnblogs.com/rjzheng/p/8972725.html)，该文指出了sorted set可以用来做**延时任务**。
    

### <span id="4">四、使用redis有什么缺点</span>

**分析**:大家用redis这么久，这个问题是必须要了解的，基本上使用redis都会碰到一些问题，常见的也就几个。  
**回答**:主要是四个问题  
(一)缓存和数据库双写一致性问题  
(二)缓存雪崩问题  
(三)缓存击穿问题  
(四)缓存的并发竞争问题  
答案继续往下看。


### <span id="11">十一、Redis单机、集群部署</span>
#### 单机部署
场景：容量或请求不高的小型存储
 * 主从模式，一个master，至少一个slave,主从两个哨兵(sentinel)
 * sentinel作用：监控(所有redis是否正常运行)；故障转移(当master节点发生宕机时，Sentinel会提升 slave 节点为新的 maste)
 * 缺点：请求多了，性能瓶颈；扩容时只能停机扩容
#### 集群部署
 场景：当容量超过20G或者系统吞吐量qps超过20w/s时，建立集群。通过中间件将流量分散到各个实例。
 

> reference：
[cnblogs](https://www.cnblogs.com/rjzheng/p/9096228.html)
[cnblogs](https://www.cnblogs.com/rjzheng/p/9096228.html)  
[csdn](https://blog.csdn.net/fuyuwei2015/article/details/72870131)  
[scienjus](http://www.scienjus.com/redis-use-case/)  
[Cyc2018](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/Redis.md#%E5%9B%9Bredis-%E4%B8%8E-memcached)
[wx](https://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&mid=2653550162&idx=1&sn=3a028865fe152de7b337c910c00b9ba2&chksm=813a67cab64deedc132ca69ea690f3164c4a0027a7f975284c849a7281ef778a8d102fccabde&scene=21#wechat_redirect)
