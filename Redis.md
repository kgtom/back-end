## 本节大纲 
* [一、为什么使用redis](#1)  
* [二、单线程的redis为什么这么快](#2)  
* [三、redis的数据类型，以及每种数据类型的使用场景](#3)  
* [四、使用redis有什么缺点](#4)  
* [五、redis的过期策略以及内存淘汰机制](#5)  
* [六、redis和数据库双写一致性问题](#6)  
* [七、如何应对缓存穿透和缓存雪崩问题](#7)  
* [八、如何解决redis的并发竞争问题](#8)  
* [九、如何利用redis分布式锁实现控制并发](#9)  
* [十、Redis与Memcached比较](#10)



### <span id="1">一、为什么使用redis</span>

**分析**:博主觉得在项目中使用redis，主要是从两个角度去考虑:**性能**和**并发**。当然，redis还具备可以做分布式锁等其他功能，但是如果只是为了分布式锁这些其他功能，完全还有其他中间件(如zookpeer等)代替，并不是非要使用redis。因此，这个问题主要从性能和并发两个角度去答。  
**回答**:如下所示，分为两点  
**（一）性能**  
如下图所示，我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够**迅速响应**。  
![image](https://images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_redis1.png)  
  
**（二）并发**  
如下图所示，在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。  
![image](https://images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_redis2.png)



###  <span id="2">二、单线程的redis为什么这么快</span>

**分析**:这个问题其实是对redis内部机制的一个考察。其实根据博主的面试经验，很多人其实都不知道redis是单线程工作模型。所以，这个问题还是应该要复习一下的。  
**回答**:主要是以下三点  
(一)纯内存操作  
(二)单线程操作，避免了频繁的上下文切换  
(三)采用了非阻塞**I/O多路复用机制**

**题外话：**我们现在要仔细的说一说I/O多路复用机制，因为这个说法实在是太通俗了，通俗到一般人都不懂是什么意思。博主打一个比方：小曲在S城开了一家快递店，负责同城快送服务。小曲因为资金限制，雇佣了**一批**快递员，然后小曲发现资金不够了，只够买**一辆**车送快递。  
**经营方式一**  
客户每送来一份快递，小曲就让一个快递员盯着，然后快递员开车去送快递。慢慢的小曲就发现了这种经营方式存在下述问题

*   几十个快递员基本上时间都花在了抢车上了，大部分快递员都处在闲置状态，谁抢到了车，谁就能去送快递
*   随着快递的增多，快递员也越来越多，小曲发现快递店里越来越挤，没办法雇佣新的快递员了
*   快递员之间的协调很花时间

综合上述缺点，小曲痛定思痛，提出了下面的经营方式  
**经营方式二**  
小曲只雇佣一个快递员。然后呢，客户送来的快递，小曲按**送达地点**标注好，然后**依次**放在一个地方。最后，那个快递员**依次**的去取快递，一次拿一个，然后开着车去送快递，送好了就回来拿下一个快递。

**对比**  
上述两种经营方式对比，是不是明显觉得第二种，效率更高，更好呢。在上述比喻中:

*   每个快递员------------------>每个线程
*   每个快递-------------------->每个socket(I/O流)
*   快递的送达地点-------------->socket的不同状态
*   客户送快递请求-------------->来自客户端的请求
*   小曲的经营方式-------------->服务端运行的代码
*   一辆车---------------------->CPU的核数

于是我们有如下结论  
1、经营方式一就是传统的并发模型，每个I/O流(快递)都有一个新的线程(快递员)管理。  
2、经营方式二就是I/O多路复用。只有单个线程(一个快递员)，通过跟踪每个I/O流的状态(每个快递的送达地点)，来管理多个I/O流。

下面类比到真实的redis线程模型，如图所示  
![image](https://images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_redis3.png)  
参照上图，简单来说，就是。我们的redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。  
需要说明的是，这个I/O多路复用机制，redis还提供了select、epoll、evport、kqueue等多路复用函数库，大家可以自行去了解。

###  <span id="3">三、redis的数据类型，以及每种数据类型的使用场景</span>

**分析**：建议，在项目中用到后，再类比记忆，体会更深，不要硬记。基本上，一个合格的程序员，五种类型都会用到。  
**回答**：一共五种

#### (一)String

最常规的set/get操作，value可以是String也可以是数字。  
**场景**：

*   **缓存功能**：(序列化用户信息、详情页面信息）
*   结合 **incr命令**做 [计数、限流api功能](http://www.redis.cn/commands/incr.html)

#### (二)hash

特别适合用于存储对象，value存放结构化的对象，方便的就是操作其中的某个字段。

**场景**：

*   做**用户登录**的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。
    
*   每条微博都有点赞数、评论数、转发数和浏览数四条属性，这时用`hash`进行计数会更好，将该计数器的 key 设为`weibo:weibo_id`，`hash`的 field 为`like_number`、`comment_number`、`forward_number`和`view_number`，在对应操作后通过**hincrby**使`hash 中`的 field 自增
    

#### (三)list

简单的字符串列表，按照插入顺序排序

**场景**：

*   **做简单的消息队列的功能**。
    
*   **做基于redis的分页功能**，性能极佳，用户体验好。
    
*   `list`作为双向链表，不光可以作为队列使用。如果将它用作栈便可以成为一个公用的时间轴。当用户发完微博后，都通过`lpush`将它存放在一个 key 为`LATEST_WEIBO`的`list`中，之后便可以通过`lrange`取出当前最新的微博。
    

#### (四)set

String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。  
Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。

**场景**：

*   因为set堆放的是一堆不重复值的集合。所以可以做**全局去重的功能**。
    
*   **好友关系** 使用交集、并集、差集等操作，可以**计算共同喜好，全部的喜好，自己独有的喜好等功能**。
    
*   **倒排索引** 是构造搜索功能的最常见方式，在 Redis 中也可以通过`set`进行建立倒排索引，这里以简单的拼音 \+ 前缀搜索城市功能举例：
    

假设一个城市`北京`，通过拼音词库将`北京`转为`beijing`，再通过前缀分词将这两个词分为若干个前缀索引，有：`北`、`北京`、`b`、`be`…`beijin`和`beijing`。将这些索引分别作为`set`的 key（例如:`index:北`）并存储`北京`的 id，倒排索引便建立好了。接下来只需要在搜索时通过关键词取出对应的`set`并得到其中的 id 即可。

#### (五)sorted set

有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。

**场景**：

*   **排行榜** 如果应用有一个发帖排行榜的功能，便选择`sorted set`吧，将集合的 key 设为`POST_RANK`。当用户发帖后，使用`zincrby`将该用户 id 的 score 增长 1。`sorted set`会重新进行排序，用户所在排行榜的位置也就会得到实时的更新。
    
*   参照另一篇[《分布式之延时任务方案解析》](https://www.cnblogs.com/rjzheng/p/8972725.html)，该文指出了sorted set可以用来做**延时任务**。
    

### <span id="4">四、使用redis有什么缺点</span>

**分析**:大家用redis这么久，这个问题是必须要了解的，基本上使用redis都会碰到一些问题，常见的也就几个。  
**回答**:主要是四个问题  
(一)缓存和数据库双写一致性问题  
(二)缓存雪崩问题  
(三)缓存击穿问题  
(四)缓存的并发竞争问题  
答案继续往下看。



> reference：
[cnblogs](https://www.cnblogs.com/rjzheng/p/9096228.html)
[cnblogs](https://www.cnblogs.com/rjzheng/p/9096228.html)  
[csdn](https://blog.csdn.net/fuyuwei2015/article/details/72870131)  
[scienjus](http://www.scienjus.com/redis-use-case/)  
[Cyc2018](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/Redis.md#%E5%9B%9Bredis-%E4%B8%8E-memcached)
