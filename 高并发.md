## 学习大纲
- [一、高并发是什么？](#1)
- [二、高并发重要参数](#2)
- [三、如何提高高并发](#3)
- [四、典型场景案例分析](#4)


## <span id="1">一、高并发是什么？</span>
 **并发：**
 操作系统并发指 cpu同时处理多件任务，互联网高并发多指某个时间点有多少个访问同时到来，通常指日PV量。
 
## <span id="2">二、高并发参数</span>
**QPS：** 每秒钟请求或者查询的数量，在互联网领域，指每秒响应请求数(指HTTP请求)

**吞吐量：** 单位时间内处理的请求数量(通常由QPS与并发数决定)

**响应时间：** 从请求发出到收到响应花费的时间，例如系统处理一个HTTP请求需要100ms，这个100ms就是系统的响应时间

**PV：** 综合浏览量(Page View)，即页面浏览量或者点击量，一个访客在24小时内访问的页面数量，同一个人浏览你的网站同一页面，只记作一次PV

**UV：** 独立访问(UniQue Visitor)，即一定时间范围内相同访客多次访问网站，只计算为1个独立访客

**带宽：** 计算带宽大小需关注两个指标，峰值流量和页面的平均大小 

日网站带宽=PV/统计时间(换算到秒)*平均页面大小(单位KB)*8

峰值一般是平均值的倍数，根据实际情况来定

QPS不等于并发连接数

QPS是每秒HTTP请求数量，并发连接数是系统同时处理的请求数量

(总PV数*80%)/(6小时秒数*20%)=峰值每秒请求数(QPS)

80%的访问量集中在20%的时间！！！
 

  随着QPS的增长，每个阶段需要根据实际情况来进行优化，优化的方案也与硬件条件、网络带宽息息相关。


## <span id="3">三、如何提高高并发</span>


## <span id="4">四、典型场景案例分析</span>
**特价机票秒杀场景**
### 1.流程
      前端下单、后台扣减库存
### 2.需要考虑点
   - 瞬间访问量激增---->消峰(nsq)
   - 请求数量>库存数量 ----->异步(nsq)+缓存(读写缓存，然后再同步到db)
   
### 3.前后端需要做的事情

  #### 前端:

1. 页面静态化：将活动页面上的所有可以静态的元素全部静态化，并尽量减少动态元素。通过CDN来抗峰值。 
2. 禁止重复提交：用户点击【下单】按钮之后，按钮置灰，js 禁止重复提交 
3. 用户限流：在某一时间段内只允许用户提交一次请求，比如可以使用Nginx对IP限流(漏桶原理)，如同安检，每次只能进入3人，多了排队，然后依次进入。

#### 后端:

##### 1.网关层
限制 登录用户 UserId 访问频率：我们上面拦截了浏览器访问的请求，但针对某些恶意攻击或其它插件，在服务端控制层需要针对同一个访问 UserId，限制访问频率,使用redis中incr命令。

##### 2.服务层
上面只拦截了一部分访问请求，当秒杀的用户量很大时，即使每个用户只有一个请求，到服务层的请求数量还是很大。比如我们有100W用户同时抢100张北京飞洛杉矶商务舱机票，服务层并发请求压力至少为100W。

* 采用消息队列nsq 缓存请求：既然服务层知道库存只有100张机票，那完全没有必要把100W个请求都传递到数据库啊，那么可以先把这些请求都写到消息队列nsq缓存一下，数据库层订阅消息减库存，减库存成功的请求返回秒杀成功，失败的返回秒杀结束。

* 利用缓存应对读请求：对类似于12306等购票业务，是典型的读多写少业务，大部分请求是查询请求，所以可以利用缓存分担数据库压力,从缓存中查询100张机票票数及信息。

* 利用缓存应对写请求：缓存也是可以应对写请求的，比如我们就可以把数据库中的库存数据转移到Redis缓存中，所有减库存操作都在Redis中进行，然后再通过后台进程把Redis中的用户秒杀请求同步到数据库中。
##### 3.数据库层
数据库层是最脆弱的一层，一般在应用设计时在上游就需要把请求拦截掉，数据库层只承担“能力范围内”的访问请求。所以，上面通过在服务层引入队列和缓存，让最底层的数据库高枕无忧。
  

## reference
* [csdn](https://blog.csdn.net/beihenanfei/article/details/78919682)
* [cnblogs](https://www.cnblogs.com/New-Zealand/p/5165663.html)
* [cnblogs](https://www.cnblogs.com/wangzhongqiu/p/6557596.html)

 
