# 学习大纲
* [一、生活中的数据结构](#1)
* [二、常见的数据结构](#2)
* [三、数据结构优缺点](#3)

## <span id="1">一、生活中数据结构</span>
* 栈：洗盘子，洗完一个，放在前一个上面，取盘子的时候，从最后一个盘子开始取。
* 队列：做地铁排队，依次进入车厢
* 树：自顶而下公司结构、二叉树
* 图：各种图，例如交通网图，当使用地图功能查询两地之间的路线，此时利用了图的存储和遍历运算，求出最优解。现实生活很多复杂问题都可以通过图解决，一图胜千言啊。
* 集合：字典kv



## <span id="2">二、常见的数据结构</span>
**数据结构：数据之间关系及存储、组织数据的方式**
结合业务特点，选择合适的数据结构。

### 0.数组
* 内存连续，固定大小。
* 查询O(1),插入、删除 O(n)， 因为移动其它元素插入O(n),如果插入最后一个O(1)
### 1、栈

* 一种特殊线性结构，先进后出，查询、插入和删除只能在栈顶进行 
* 插入、删除只需要改变节点next的指向 O(1),查询O(n),需要逐节点查找
* [代码地址链接](https://github.com/kgtom/back-end/blob/master/leetcode/stack.md)


### 2、队列
* 先进先出的线性结构，队尾插入，对头访问和删除
* [代码地址链接](https://github.com/kgtom/back-end/blob/master/leetcode/queue.md)

### 3.链表
* 链表就是线性表的链式存储方式。链表的内存是不连续的
* [代码地址链接](https://github.com/kgtom/back-end/blob/master/leetcode/list.md)


### 4.树

#### 1.各种树概念
* 树：有>=0个子节点，没有左右之分
* 二叉树：每个节点最多有两个子树，子树有左右之分，通常用于二叉树查找和二叉堆。
 深度为k的二叉树总节点最多有2^k-1个节点。（等比数列 1+2+4+…+2^(k-1) = 2^k-1）
* 满二叉树：除最后一层无任何节点外，每一层上所有节点都是两个，深度为k,总节点 2^k-1个节点，总节点为奇数，若总节点为n,则数高h(或者深度k)=log2^(n+1),第k层上节点为 2^(k-1)个。
* 完全二叉树：若树深度h,除h层，其它层节点都达到最大数两个，h层节点集中在左树上。效率最高的树。**满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树**。堆是一种完全二叉树。树高h=log2^n + 1，总节点最多有2^k-1个节点。
* 二叉查找树：又称为是二叉排序树（Binary Sort Tree）或二叉搜索树。
* 平衡二叉树：平衡二叉树（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用算法有红黑树、AVL树等。在平衡二叉搜索树中，我们可以看到，其高度一般都良好地维持在O(log2n)，大大降低了操作的时间复杂度。
* B树也是一种用于查找的平衡树，但是它不是二叉树。从根节点搜索--->左节点--->右节点
* B+树是B树的变体，也是一种多路搜索树。
* B*树是B+树的变体，在B+树的非根和非叶子节点再增加指向兄弟的指针，将节点的最低利用率从1/2提高到2/3。
* Tire树称为字典树，又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计

#### 2.二叉树的四种遍历方法

分深度遍历和广度优先遍历，其中深度遍历包括前序、中序、后序，广度优先遍历就是层次遍历实际就是前序遍历。
* 1.前序遍历:中左右
* 2.中序遍历：左中右
* 3.后序遍历：左右中
* 4.层序遍历：从顶而下逐层遍历，每一层遵循从左向右。
 [代码地址](http://39.106.173.209:88/tree-order-traversal/)
 
 #### 3.二叉查找树
 * 1.性能分析：给定的值相同但顺序不同时，组合二叉树的形态不同，查找时间复杂度也就不同了。
![bst](https://github.com/kgtom/back-end/blob/master/pic/bst.jpg)
  ** 左图是bst树以扇形结构散开，时间复杂度：它和二分查找一样，插入、删除、查找的时间复杂度均为O(logn)
  ** 右图bst树不是以扇形结构散开，是一颗单支树，这种查找类似于数组查找，是O(n)，原因在于插入和删除元素的时候，树没有保持两边平衡，而是单支树
  **总结** 查找复杂度取决于树的拓扑结构，最佳 O(logn),最差O(n)
* 2.二叉树新增、排序、查找、修改、删除操作



**总结:**
* 先序遍历是中左右，先获取到中，然后在深入时按照右左顺序push，这样出栈就是左右了。
* 中序遍历是在从左子树开始深入，不能再深入了，就返回，返回时遇到结点就访问，即：左节点不能再深入的就是起点。
* 后序遍历是从右子树返回时遇到结点就访问 
在这一过程中，先访问的数据后输出，也就是最后访问的先输出，正好符合 stack 结构先进后出的特点。由此，可以利用 stack 实现这一遍历路线

#### 3.数组转换成tree
~~~go
package main

import (
	"fmt"
)

func main() {

	arr := []int{1, 4, 2, 3}
	ret := Ints2TreeNode(arr)
	fmt.Println("ret:", ret)
}

//将 []ints 转换成tree,根据前序遍历，中左右
func Ints2TreeNode(ints []int) *TreeNode {
	n := len(ints)
	if n == 0 {
		return nil
	}

	root := &TreeNode{
		Val: ints[0],
	}

	tempArr := make([]*TreeNode, 1)
	//先取根节点
	tempArr[0] = root

	i := 1
	for i < n {
		//每次都取第一个，作为下一个节点的根节点。
		node := tempArr[0]
		tempArr = tempArr[1:]
		if i < n && ints[i] != 0 {
			//先给左节点，再给右节点，本例子按照前序遍历，中左右
			node.Left = &TreeNode{Val: ints[i]}
			tempArr = append(tempArr, node.Left)
		}
		i++

		if i < n && ints[i] != 0 {
			//再给右节点
			node.Right = &TreeNode{Val: ints[i]}
			tempArr = append(tempArr, node.Right)
		}
		i++
	}

	return root
}

~~~
### 5.堆
* 堆实际上是一颗 完全二叉树 ，它满足父节点大于（或小于）子节点特性。父节点大于子节节点称为最大堆（arr[i]>=arr[2i] && arr[i]>=array[2i+1]），父节点小于子节点称为最小堆（arr[i]<=arr[2i] && arr[i]<=arr[2i+1]）
* 包括：上浮、下沉、插入、获取等操作
* [代码地址链接](https://github.com/kgtom/back-end/blob/master/leetcode/heap.md)


### 6.图
* 图是描述事物之间关系的
* [代码地址链接](http://)

## <span id="3">三、数据结构优缺点</span>


|数据结构	|优点	|缺点|
| - | :- | :- | 
|数组|	插入快，如果知道下标，可以非常快的存取	|查找慢，删除慢，大小固定
|有序数组|	比无序的数组查找快|	删除和插入慢，大小固定|
栈|	提供后进先出方式的存取	|存取其他项很慢
队列|	提供先进先出方式的存取	|存取其他项很慢
链表|	插入快，|删除快	查找慢
二叉树|	查找，插入，删除都快（如果树保持平衡）	|删除算法复杂
红-黑树|	查找，插入，删除都快，树总是平衡的	|算法复杂
2-3-4树|	查找，插入，删除都快，树总是平衡的，类似的树对磁盘存储有用|	算法复杂
哈希表|	如果关键字已知则存取极快，插入快	|删除慢，如果不知道关键词则存取很慢，对存储空间使用不充分
堆|	插入删除快，对最大数据项的存取很快|	对其他数据项存取慢
图|	对现实世界建模|	有些算法慢且复杂

>reference:
* [csdn](https://blog.csdn.net/u014419014/article/details/78770812)
* [csdn](https://blog.csdn.net/qq_15654993/article/details/75267581)
* [cnblogs--思路清晰](https://www.cnblogs.com/JVxie/p/4859889.html)
* [jobbole--各种树](http://blog.jobbole.com/111680/)




