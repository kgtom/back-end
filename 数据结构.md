# 学习大纲
* [一、生活中的数据结构](#1)
* [二、常见的数据结构](#2)
* [三、数据结构优缺点](#3)

## <span id="1">一、生活中数据结构</span>
* 栈：洗盘子，洗完一个，放在前一个上面，取盘子的时候，从最后一个盘子开始取。
* 队列：做地铁排队，依次进入车厢
* 树：自顶而下公司结构、二叉树
* 图：各种图，例如交通网图，当使用地图功能查询两地之间的路线，此时利用了图的存储和遍历运算，求出最优解。现实生活很多复杂问题都可以通过图解决，一图胜千言啊。
* 集合：字典kv



## <span id="2">二、常见的数据结构</span>
**数据结构：数据之间关系及存储、组织数据的方式**
结合业务特点，选择合适的数据结构。

### 0.数组
* 内存连续，固定大小。
* 查询O(1),插入、删除 O(n)， 因为移动其它元素插入O(n),如果插入最后一个O(1)
### 1、栈

* 一种特殊线性结构，先进后出，查询、插入和删除只能在栈顶进行 
* 插入、删除只需要改变节点next的指向 O(1),查询O(n),需要逐节点查找
* [代码地址链接](https://github.com/kgtom/back-end/blob/master/leetcode/stack.md)


### 2、队列
* 先进先出的线性结构，队尾插入，对头访问和删除
* [代码地址链接](https://github.com/kgtom/back-end/blob/master/leetcode/queue.md)

### 3.链表
* 链表就是线性表的链式存储方式。链表的内存是不连续的
* [代码地址链接](https://github.com/kgtom/back-end/blob/master/leetcode/list.md)


### 4.树

#### 1.各种树概念
* 树：有>=0个子节点，没有左右之分
* 二叉树：每个节点最多有两个子树，子树有左右之分，通常用于二叉树查找和二叉堆。
 深度为k的二叉树总节点最多有2^k-1个节点。（等比数列 1+2+4+…+2^(k-1) = 2^k-1）
* 满二叉树：除最后一层无任何节点外，每一层上所有节点都是两个，深度为k,总节点 2^k-1个节点，总节点为奇数，若总节点为n,则数高h(或者深度k)=log2^(n+1),第k层上节点为 2^(k-1)个。
* 完全二叉树：若树深度h,除h层，其它层节点都达到最大数两个，h层节点集中在左树上。效率最高的树。**满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树**。堆是一种完全二叉树。树高h=log2^n + 1，总节点最多有2^k-1个节点。
* 二叉查找树：又称为是二叉排序树（Binary Sort Tree）或二叉搜索树。二叉查找树的时间复杂度：它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡
* 平衡二叉树：平衡二叉树（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用算法有红黑树、AVL树等。在平衡二叉搜索树中，我们可以看到，其高度一般都良好地维持在O(log2n)，大大降低了操作的时间复杂度。
* B树也是一种用于查找的平衡树，但是它不是二叉树。从根节点搜索--->左节点--->右节点
* B+树是B树的变体，也是一种多路搜索树。
* B*树是B+树的变体，在B+树的非根和非叶子节点再增加指向兄弟的指针，将节点的最低利用率从1/2提高到2/3。
* Tire树称为字典树，又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计

#### 2.二叉树的四种遍历方法

分深度遍历和广度优先遍历，其中深度遍历包括前序、中序、后序，广度优先遍历就是层次遍历实际就是前序遍历。
* 1.前序遍历:中左右

~~~go
package main

import (
	"fmt"
	"sync"
)

func main() {

	//将二叉树按照前序遍历输出到[]int中

	tree := &TreeNode{
		Val: 1,
		//Left: &TreeNode{
		//	Val: 4,
		//},
		Right: &TreeNode{
			Val: 2,
			Left: &TreeNode{
				Val: 3,
			},
		},
	}
	ret := preorderTraversal(tree)
	fmt.Println("ret:", ret)

}

// TreeNode
type TreeNode struct {
	Val   int
	Left  *TreeNode
	Right *TreeNode
}

type Stack struct {
	lock sync.Mutex
	node []*TreeNode
}

func NewStack() *Stack {

	return &Stack{lock: sync.Mutex{}, node: []*TreeNode{}}
}

func (s *Stack) Push(node *TreeNode) {
	s.lock.Lock()
	defer s.lock.Unlock()

	s.node = append(s.node, node)
}

func (s *Stack) Pop() *TreeNode {
	s.lock.Lock()

	defer s.lock.Unlock()
	n := len(s.node)
	if n == 0 {
		return nil
	}
	ret := s.node[n-1]
	s.node = s.node[:(n - 1)]

	return ret
}

//二叉树前序遍历：时间复杂度O(n) 空间复杂度(n)
func preorderTraversal(tree *TreeNode) []int {

	s := NewStack()

	//将tree,push 到栈里面
	s.Push(tree)
	ret := []int{}

	//使用stack 栈，注意其特性，先进后出。

	for len(s.node) != 0 {

		//获取当前节点,首次实际就是根节点值
		curr := s.Pop()
		ret = append(ret, curr.Val)

		//如果当前节点存在右节点，则入栈
		//如果当前节点存在左节点，则入栈
		//先 push right节点，后 push left,是因为栈的特性：先进后出，又因为前序遍历，需要先让左节点出来，后右节点出来。
		if curr.Right != nil {
			s.Push(curr.Right)
		}
		if curr.Left != nil {
			s.Push(curr.Left)
		}

	}
	fmt.Println("len:", len(s.node)) //0
	return ret
}


~~~
* 2.中序遍历：左中右
* 3.后序遍历：左右中
* 4.层序遍历：从顶而下逐层遍历，每一层遵循从左向右。

**总结:**
* 先序遍历是中左右，先获取到中，然后在深入时按照右左顺序push，这样出栈就是左右了。
* 中序遍历是在从左子树开始深入，不能再深入了，就返回，返回时遇到结点就访问，即：左节点不能再深入的就是起点。
* 后序遍历是从右子树返回时遇到结点就访问 
在这一过程中，先访问的数据后输出，也就是最后访问的先输出，正好符合 stack 结构先进后出的特点。由此，可以利用 stack 实现这一遍历路线

#### 3.数组转换成tree
~~~go
package main

import (
	"fmt"
)

func main() {

	arr := []int{1, 4, 2, 3}
	ret := Ints2TreeNode(arr)
	fmt.Println("ret:", ret)
}

//将 []ints 转换成tree,根据前序遍历，中左右
func Ints2TreeNode(ints []int) *TreeNode {
	n := len(ints)
	if n == 0 {
		return nil
	}

	root := &TreeNode{
		Val: ints[0],
	}

	tempArr := make([]*TreeNode, 1)
	//先取根节点
	tempArr[0] = root

	i := 1
	for i < n {
		//每次都取第一个，作为下一个节点的根节点。
		node := tempArr[0]
		tempArr = tempArr[1:]
		if i < n && ints[i] != 0 {
			//先给左节点，再给右节点，本例子按照前序遍历，中左右
			node.Left = &TreeNode{Val: ints[i]}
			tempArr = append(tempArr, node.Left)
		}
		i++

		if i < n && ints[i] != 0 {
			//再给右节点
			node.Right = &TreeNode{Val: ints[i]}
			tempArr = append(tempArr, node.Right)
		}
		i++
	}

	return root
}

~~~
### 5.堆
* 堆实际上是一颗 完全二叉树 ，它满足父节点大于（或小于）子节点特性。父节点大于子节节点称为最大堆（arr[i]>=arr[2i] && arr[i]>=array[2i+1]），父节点小于子节点称为最小堆（arr[i]<=arr[2i] && arr[i]<=arr[2i+1]）
* 包括：上浮、下沉、插入、获取等操作
* [代码地址链接](https://github.com/kgtom/back-end/blob/master/leetcode/heap.md)


### 6.图
* 图是描述事物之间关系的
* [代码地址链接](http://)

## <span id="3">三、数据结构优缺点</span>


|数据结构	|优点	|缺点|
| - | :- | :- | 
|数组|	插入快，如果知道下标，可以非常快的存取	|查找慢，删除慢，大小固定
|有序数组|	比无序的数组查找快|	删除和插入慢，大小固定|
栈|	提供后进先出方式的存取	|存取其他项很慢
队列|	提供先进先出方式的存取	|存取其他项很慢
链表|	插入快，|删除快	查找慢
二叉树|	查找，插入，删除都快（如果树保持平衡）	|删除算法复杂
红-黑树|	查找，插入，删除都快，树总是平衡的	|算法复杂
2-3-4树|	查找，插入，删除都快，树总是平衡的，类似的树对磁盘存储有用|	算法复杂
哈希表|	如果关键字已知则存取极快，插入快	|删除慢，如果不知道关键词则存取很慢，对存储空间使用不充分
堆|	插入删除快，对最大数据项的存取很快|	对其他数据项存取慢
图|	对现实世界建模|	有些算法慢且复杂

>reference:
* [csdn](https://blog.csdn.net/u014419014/article/details/78770812)
* [csdn](https://blog.csdn.net/qq_15654993/article/details/75267581)
* [cnblogs--思路清晰](https://www.cnblogs.com/JVxie/p/4859889.html)
* [jobbole--各种树](http://blog.jobbole.com/111680/)




